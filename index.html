<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Red Dot Game (Explosion AOE)</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}
		#gameCanvas {
			display: block;
			margin: 0 auto;
			border: 3px solid black;
		}
		#toggleGreen {
			position: absolute;
			top: 20px;
			right: 20px;
			z-index: 10;
			background: darkgreen;
			color: white;
			border: none;
			padding: 10px 20px;
			border-radius: 10px;
			font-size: 18px;
			cursor: pointer;
		}
	</style>
</head>
<body>

<canvas id="gameCanvas" width="1200" height="800"></canvas>
<button id="toggleGreen">Tắt Green</button>

<script>
// Setup canvas
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Load images
const bgImg = new Image(); bgImg.src = "bg.png";
const redImg = new Image(); redImg.src = "red.png";
const greenImg = new Image(); greenImg.src = "green.png";
const meteorImg = new Image(); meteorImg.src = "/Particle FX 1.3 Free/meteor.png";
const gameOverImg = new Image(); gameOverImg.src = "gameover.png";
const explosionSprite = new Image(); explosionSprite.src = "/Particle FX 1.3 Free/pngegg.png"; // 4x5 sprite sheet

// Game data
const redDot = {
	x: 100, y: 350,
	width: 90, height: 60,
	speed: 8
};

let obstacles = [];
let meteors = [];
let explosions = [];
let gameOver = false;
let score = 0;
let greenEnabled = true;
let meteorWaveActive = false;
let meteorWaveTimer = 0;
let lastScoreCheckpoint = 0;

// Controls
let keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

// Toggle green obstacles
const toggleBtn = document.getElementById("toggleGreen");
toggleBtn.addEventListener("click", () => {
	greenEnabled = !greenEnabled;
	toggleBtn.textContent = greenEnabled ? "Tắt Green" : "Bật Green";
});

// Meteor logic
function spawnMeteor() {
	const size = 60;
	const x = randomSpawn(canvas.width / 1.5,(canvas.width * 2) - 400)
	const y = randomSpawn(-(canvas.height - 150), 50);
	const speedX = 4, speedY = 3;
	meteors.push({ x, y, size, speedX, speedY, birthTime: Date.now() });
}

function randomSpawn(min , max) {
	return Math.random() * (max - min) + min;
}


function drawMeteors() {
	meteors.forEach(m => ctx.drawImage(meteorImg, m.x, m.y, m.size, m.size));
}

function updateMeteors() {
	const now = Date.now();
	for (let i = 0; i < meteors.length; i++) {
		let m = meteors[i];
		m.x -= m.speedX;
		m.y += m.speedY;
		if (now - m.birthTime >= 1500) {
			spawnExplosion(m.x - m.size, m.y - m.size);
			meteors.splice(i, 1); i--;
		}
	}
}

// Explosion logic
function spawnExplosion(x, y) {
	explosions.push({
		x, y,
		frame: 0, frameMax: 20,
		frameWidth: 192, frameHeight: 192,
		frameSpeed: 3, frameCounter: 0
	});
}

function updateExplosions() {
	for (let i = 0; i < explosions.length; i++) {
		let exp = explosions[i];
		exp.frameCounter++;
		if (exp.frameCounter >= exp.frameSpeed) {
			exp.frame++; exp.frameCounter = 0;
		}
		if (exp.frame >= exp.frameMax) {
			explosions.splice(i, 1); i--;
			continue;
		}

		if (exp.frame > 5) {
			const hitboxScale = 0.5;
			const reducedWidth = exp.frameWidth * hitboxScale;
			const reducedHeight = exp.frameHeight * hitboxScale;
			const explosionBox = {
				x: exp.x + (exp.frameWidth - reducedWidth) / 2,
				y: exp.y + (exp.frameHeight - reducedHeight) / 2,
				width: reducedWidth,
				height: reducedHeight
			};

			if (
				redDot.x < explosionBox.x + explosionBox.width &&
				redDot.x + redDot.width > explosionBox.x &&
				redDot.y < explosionBox.y + explosionBox.height &&
				redDot.y + redDot.height > explosionBox.y
			) {
				gameOver = true;
			}
		}
	}
}

function drawExplosions() {
	for (let exp of explosions) {
		let col = exp.frame % 4;
		let row = Math.floor(exp.frame / 4);
		ctx.drawImage(
			explosionSprite,
			col * exp.frameWidth,
			row * exp.frameHeight,
			exp.frameWidth,
			exp.frameHeight,
			exp.x, exp.y,
			exp.frameWidth,
			exp.frameHeight
		);
	}
}

// Red dot movement
function moveRedDot() {
	if (keys["w"] || keys["ArrowUp"]) redDot.y -= redDot.speed;
	if (keys["s"] || keys["ArrowDown"]) redDot.y += redDot.speed;
	if (keys["a"] || keys["ArrowLeft"]) redDot.x -= redDot.speed;
	if (keys["d"] || keys["ArrowRight"]) redDot.x += redDot.speed;

	// Clamp
	redDot.y = Math.max(0, Math.min(canvas.height - redDot.height, redDot.y));
	redDot.x = Math.max(0, Math.min(canvas.width - redDot.width, redDot.x));
}

// Obstacles
function spawnObstacle() {
	const y = Math.random() * (canvas.height - 60);
	obstacles.push({ x: canvas.width, y, width: 90, height: 60, speed: 6 });
}

function updateObstacles() {
	obstacles.forEach(obs => obs.x -= obs.speed);
	obstacles = obstacles.filter(obs => obs.x + obs.width > 0);
}

function drawObstacles() {
	for (let obs of obstacles) {
		ctx.drawImage(greenImg, obs.x, obs.y, obs.width, obs.height);
	}
}

function detectCollision() {
	for (let obs of obstacles) {
		if (
			redDot.x < obs.x + obs.width &&
			redDot.x + redDot.width > obs.x &&
			redDot.y < obs.y + obs.height &&
			redDot.y + redDot.height > obs.y
		) {
			gameOver = true;
		}
	}
}

// UI
function drawScore() {
	ctx.fillStyle = "white";
	ctx.font = "30px Arial";
	ctx.fillText("Score: " + score, 20, 40);
}

// Game loop
let spawnTimer = 0;
let scoreTimer = 0;

function gameLoop() {
	ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

	if (gameOver) {
		ctx.drawImage(gameOverImg, 0, 0, canvas.width, canvas.height);
		ctx.fillStyle = "white";
		ctx.font = "50px Arial";
		ctx.fillText("GAME OVER", 430, 330);
		ctx.font = "32px Arial";
		ctx.fillText("Final Score: " + score, 480, 530);
		return;
	}

	moveRedDot();
	ctx.drawImage(redImg, redDot.x, redDot.y, redDot.width, redDot.height);

	updateObstacles();
	drawObstacles();
	detectCollision();

	updateMeteors();
	drawMeteors();

	updateExplosions();
	drawExplosions();

	// Spawn green nếu được bật
	spawnTimer++;
	if (greenEnabled && spawnTimer > 50) {
		spawnObstacle();
		spawnTimer = 0;
	}

	// Thiên thạch mỗi 30 điểm
	if (score > 0 && score % 40 === 0 && score !== lastScoreCheckpoint) {
		meteorWaveActive = true;
		meteorWaveTimer = 0;
		lastScoreCheckpoint = score;
	}

	if (meteorWaveActive) {
		meteorWaveTimer++;
		if (meteorWaveTimer % 25 === 0) spawnMeteor();
		if (meteorWaveTimer >= 420) meteorWaveActive = false; // 2 giây @ 60fps
	}

	// Tăng điểm
	scoreTimer++;
	if (scoreTimer >= 30) {
		score++;
		scoreTimer = 0;
	}

	drawScore();
	requestAnimationFrame(gameLoop);
}

window.onload = () => {
	gameLoop();
};
</script>

</body>
</html>
